<!DOCTYPE html>
<html>
<head>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="generator" content="MarkBind 2.15.2">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CS2103/T - Object Oriented Programming: Inheritance</title>
    <link rel="stylesheet" href="../../../markbind/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../../markbind/css/bootstrap-vue.min.css">
    <link rel="stylesheet" href="../../../markbind/fontawesome/css/all.min.css">
    <link rel="stylesheet" href="../../../markbind/glyphicons/css/bootstrap-glyphicons.min.css">
    <link rel="stylesheet" href="../../../markbind/css/octicons.css">
    <link rel="stylesheet" href="../../../markbind/css/github.min.css">
    <link rel="stylesheet" href="../../../markbind/css/markbind.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"><link rel="stylesheet" href="/website/plugins/markbind-plugin-anchors/markbind-plugin-anchors.css"><link rel="stylesheet" href="../../../markbind/layouts/default/styles.css"><link rel="icon" href="/website/favicon.ico"></head>
<body >
<div id="app">
    <div id="flex-body">
        <div id="content-wrapper">
<div>
<link rel="stylesheet" href="/website/book/css/textbook.css">
<div class="website-content" id="all">
<p><span class="dimmed"><strong><span>Paradigms → OOP →
</span></strong></span></p>
<div id="title">
<h1 id="inheritance"><span>Inheritance</span><a class="fa fa-anchor" href="#inheritance" onclick="event.stopPropagation()"></a></h1></div>
<div id="main">
<div>
<div>
<panel type="seamless" expanded id="what">
  <span slot="header" class="card-title"><div><h4 id="what"><span>What</span><a class="fa fa-anchor" href="#what" onclick="event.stopPropagation()"></a></h4></div></span>
  <div class="indented">
<p><span class="badge badge-light"><span><span class="dimmed"><span><span><span aria-hidden="true" class="fas fa-trophy"></span></span> Can explain the meaning of inheritance</span></span></span></span></p><p></p><p></p>
<p></p>
  <div>
<p><strong>The OOP concept <em>Inheritance</em> allows you to define a new class based on an existing class.</strong></p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> For example, you can use inheritance to define an <code v-pre>EvaluationReport</code> class based on an existing <code v-pre>Report</code> class so that the <code v-pre>EvaluationReport</code> class does not have to duplicate data/behaviors that are already implemented in the <code v-pre>Report</code> class. The <code v-pre>EvaluationReport</code> can inherit the <code v-pre>wordCount</code> attribute and the <code v-pre>print()</code> method from the <em>base class</em> <code v-pre>Report</code>.</p></box>
<ul>
<li>Other names for Base class: <em>Parent</em> class, <em>Superclass</em></li>
<li>Other names for Derived class: <em>Child</em> class, <em>Subclass</em>, <em>Extended</em> class</li></ul>
<p><strong>A superclass is said to be <em>more general</em> than the subclass.</strong> Conversely, a subclass is said to be more <em>specialized</em> than the superclass.</p>
<p><strong>Applying inheritance on a group of similar classes can result in the common parts among classes being extracted into more general classes.</strong></p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> <code v-pre>Man</code> and <code v-pre>Woman</code> behave the same way for certain things. However, the two classes cannot be simply replaced with a more general class <code v-pre>Person</code> because of the need to distinguish between <code v-pre>Man</code> and <code v-pre>Woman</code> for certain other things. A solution is to add the <code v-pre>Person</code> class as a superclass (to contain the code common to men and women) and let <code v-pre>Man</code> and <code v-pre>Woman</code> inherit from <code v-pre>Person</code> class.</p></box>
<p><strong>Inheritance implies the derived class can be considered as a <em>sub-type</em> of the base class (and the base class is a <em>super-type</em> of the derived class), resulting in an <em>is a</em> relationship.</strong></p>
<p><span class="dimmed"><span><span aria-hidden="true" class="fas fa-info-circle"></span></span> Inheritance does not necessarily mean a sub-type relationship exists. However, the two often go hand-in-hand. For simplicity, at this point let us assume inheritance implies a sub-type relationship.</span></p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> To continue the previous example,</p>
<ul>
<li><code v-pre>Woman</code> <em>is a</em> <code v-pre>Person</code></li>
<li><code v-pre>Man</code> <em>is a</em> <code v-pre>Person</code></li></ul></box>
<p><strong>Inheritance relationships through a chain of classes can result in inheritance <em>hierarchies</em> (aka inheritance <em>trees</em>).</strong></p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Two inheritance hierarchies/trees are given below. <span class="dimmed">Note that the triangle points to the parent class.</span> Observe how the <code v-pre>Parrot</code> <em>is a</em> <code v-pre>Bird</code> as well as it <em>is an</em> <code v-pre>Animal</code>.</p>
<img src="/website/book/oop/inheritance/what/images/inheritanceTreesExamples.png" width="500">
<p></p></box>
<p><strong><em>Multiple Inheritance</em> is when a class inherits <em>directly</em> from multiple classes.</strong> Multiple inheritance among classes is allowed in some languages (e.g., Python, C++) but not in other languages (e.g., Java, C#).</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The <code v-pre>Honey</code> class inherits from the <code v-pre>Food</code> class <em>and</em> the <code v-pre>Medicine</code> class <span class="dimmed">because honey can be consumed as a food as well as a medicine (in some oriental medicine practices)</span>. Similarly, a <code v-pre>Car</code> is a <code v-pre>Vehicle</code>, an <code v-pre>Asset</code> and a <code v-pre>Liability</code>.</p>
<img src="/website/book/oop/inheritance/what/images/multipleInheritanceExamples.png" width="440"></box></div>
  <div>
 <div>
<panel expandable class="algolia-no-index"><template slot="_header"><p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p></template>
  <div>
<panel class="algolia-no-index"><template slot="_header"><p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span> Which statements are correct?</p></template>
<question>
<p>Which of these are correct?</p>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> a. Superclass is more general than the subclass.</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> b. Child class is more specialized than the parent class.</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> c. A class can inherit behavior from its ancestor classes (ancestor classes = classes above it in the inheritance hierarchy).</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> d. Code reuse can be one benefit of inheritance.</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> e. A change to the superclass will not affect its subclasses.</li></ul>
<div slot="answer" class="algolia-no-index">
<p>(a) (b) (c) (d)</p>
<p>Explanation: (e) is incorrect. Because subclasses inherit behavior from the superclass, any changes to the superclass could affect subclasses.</p></div></question></panel></div></panel></div></div></div></panel></div>
<div>
<panel type="seamless" expanded id="overriding">
  <span slot="header" class="card-title"><div><h4 id="overriding"><span>Overriding</span><a class="fa fa-anchor" href="#overriding" onclick="event.stopPropagation()"></a></h4></div></span>
  <div class="indented">
<p><span class="badge badge-light"><span><span class="dimmed"><span><span><span aria-hidden="true" class="fas fa-trophy"></span></span> Can explain method overriding</span></span></span></span></p><p></p><p></p>
<p></p>
  <div>
<p><strong>Method <em>overriding</em> is when a sub-class changes the behavior inherited from the parent class</strong> by re-implementing the method. Overridden methods have the same name, same type signature, and same return type.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Consider the following case of <code v-pre>EvaluationReport</code> class inheriting the <code v-pre>Report</code> class:</p>
<div class="table-responsive"><table class="markbind-table table table-bordered table-striped"><thead>
<tr>
<th><code v-pre>Report</code> methods</th>
<th><code v-pre>EvaluationReport</code> methods</th>
<th>Overrides?</th></tr></thead>
<tbody>
<tr>
<td><code v-pre>print()</code></td>
<td><code v-pre>print()</code></td>
<td>Yes</td></tr>
<tr>
<td><code v-pre>write(String)</code></td>
<td><code v-pre>write(String)</code></td>
<td>Yes</td></tr>
<tr>
<td><code v-pre>read():String</code></td>
<td><code v-pre>read(int):String</code></td>
<td>No. <span class="dimmed">Reason: the two methods have different signatures; This is a case of <span trigger="click" for="modal:overriding-overloading" v-b-popover.click.top.html="popoverGenerator" v-b-tooltip.click.top.html="tooltipContentGetter" v-on:click="$refs['modal:overriding-overloading'].show()" class="trigger-click"> <em>overloading</em></span> (rather than overriding).</span></td></tr></tbody></table></div><b-modal id="modal:overriding-overloading" hide-footer size="lg" modal-class="mb-zoom" ref="modal:overriding-overloading" class="algolia-no-index"><template slot="modal-title"><strong>Overloading</strong></template>
  <div>
<div></div><p></p>
<p><span class="dimmed"><strong><span>Paradigms → OOP → Inheritance →
</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="overloading"><span>Overloading</span><a class="fa fa-anchor" href="#overloading" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<p><strong>Method overloading is when there are multiple methods with the same name but different type signatures.</strong> Overloading is used to indicate that multiple operations do similar things but take different parameters.</p>
<box type="definition" seamless>
<div>
<p><strong>Type signature</strong>: The <em>type signature</em> of an operation is the type sequence of the parameters. The return type and parameter names are not part of the type signature. However, the parameter order is significant.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Example:</p>
<div class="table-responsive"><table class="markbind-table table table-bordered table-striped"><thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Type Signature</th></tr></thead>
<tbody>
<tr>
<td style="text-align:center"><code v-pre>int add(int X, int Y)</code></td>
<td style="text-align:center"><code v-pre>(int, int)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void add(int A, int B)</code></td>
<td style="text-align:center"><code v-pre>(int, int)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void m(int X, double Y)</code></td>
<td style="text-align:center"><code v-pre>(int, double)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void m(double X, int Y)</code></td>
<td style="text-align:center"><code v-pre>(double, int)</code></td></tr></tbody></table></div></box></div></box>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> In the case below, the <code v-pre>calculate</code> method is overloaded because the two methods have the same name but different type signatures <code v-pre>(String)</code> and <code v-pre>(int)</code>.</p>
<ul>
<li><code v-pre>calculate(String): void</code></li>
<li><code v-pre>calculate(int): void</code></li></ul></box></div>
<div></div></div></div></div></b-modal></box></div>
  <div>
  <div>
<panel expandable class="algolia-no-index"><template slot="_header"><p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p></template>
  <div>
<panel class="algolia-no-index"><template slot="_header"><p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span> Which methods override?</p></template>
<question>
<p>Which of these methods override another method? <span class="dimmed"><code v-pre>A</code> is the parent class. <code v-pre>B</code> inherits <code v-pre>A</code>.</span></p>
<img src="/website/book/oop/inheritance/overriding/images/overriding.png" height="220">
<p></p>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> a</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> b</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> c</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> d</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> e</li></ul>
<div slot="answer" class="algolia-no-index">
<p>d</p>
<p>Explanation: Method overriding requires a method in a <em>child class</em> to use the same method name and same parameter sequence used by one of its ancestors.</p></div></question></panel></div></panel></div></div></div></panel></div>
<div>
<panel type="seamless" expanded id="overloading-2">
  <span slot="header" class="card-title"><div><h4 id="overloading-2"><span>Overloading</span><a class="fa fa-anchor" href="#overloading-2" onclick="event.stopPropagation()"></a></h4></div></span>
  <div class="indented">
<p><span class="badge badge-light"><span><span class="dimmed"><span><span><span aria-hidden="true" class="fas fa-trophy"></span></span> Can explain method overloading</span></span></span></span></p><p></p><p></p>
<p></p>
  <div>
<p><strong>Method overloading is when there are multiple methods with the same name but different type signatures.</strong> Overloading is used to indicate that multiple operations do similar things but take different parameters.</p>
<box type="definition" seamless>
<div>
<p><strong>Type signature</strong>: The <em>type signature</em> of an operation is the type sequence of the parameters. The return type and parameter names are not part of the type signature. However, the parameter order is significant.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Example:</p>
<div class="table-responsive"><table class="markbind-table table table-bordered table-striped"><thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Type Signature</th></tr></thead>
<tbody>
<tr>
<td style="text-align:center"><code v-pre>int add(int X, int Y)</code></td>
<td style="text-align:center"><code v-pre>(int, int)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void add(int A, int B)</code></td>
<td style="text-align:center"><code v-pre>(int, int)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void m(int X, double Y)</code></td>
<td style="text-align:center"><code v-pre>(int, double)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void m(double X, int Y)</code></td>
<td style="text-align:center"><code v-pre>(double, int)</code></td></tr></tbody></table></div></box></div></box>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> In the case below, the <code v-pre>calculate</code> method is overloaded because the two methods have the same name but different type signatures <code v-pre>(String)</code> and <code v-pre>(int)</code>.</p>
<ul>
<li><code v-pre>calculate(String): void</code></li>
<li><code v-pre>calculate(int): void</code></li></ul></box></div>
  <div></div></div></panel></div>
<div>
<panel type="seamless" expanded id="interfaces">
  <span slot="header" class="card-title"><div><h4 id="interfaces"><span>Interfaces</span><a class="fa fa-anchor" href="#interfaces" onclick="event.stopPropagation()"></a></h4></div></span>
  <div class="indented">
<p><span class="badge badge-light"><span><span class="dimmed"><span><span><span aria-hidden="true" class="fas fa-trophy"></span></span> Can explain interfaces</span></span></span></span></p><p></p><p></p>
<p></p>
  <div>
<p><strong>An <em>interface</em> is a behavior specification</strong> i.e. a collection of <span data-mb-component-type="tooltip" v-b-tooltip.hover.top.html="tooltipInnerContentGetter" class="trigger"><span data-mb-html-for="_content">Just the method signature without any implementation</span>method specifications</span>. If a class <span data-mb-component-type="tooltip" v-b-tooltip.hover.top.html="tooltipInnerContentGetter" class="trigger"><span data-mb-html-for="_content">implements all methods specified in an interface</span>implements the interface</span>, it means the class is able to support the behaviors specified by the said interface.</p>
<blockquote>
<p>There are a number of situations in software engineering when it is important for disparate groups of programmers to agree to a &quot;contract&quot; that spells out how their software interacts. Each group should be able to write their code without any knowledge of how the other group's code is written. Generally speaking, interfaces are such contracts. <sub>--<a href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">Oracle Docs on Java</a><sub></sub></sub></p></blockquote>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Suppose <code v-pre>SalariedStaff</code> is an interface that contains two methods <code v-pre>setSalary(int)</code> and <code v-pre>getSalary()</code>. <code v-pre>AcademicStaff</code> can declare itself as <em>implementing</em> the <code v-pre>SalariedStaff</code> interface, which means the <code v-pre>AcademicStaff</code> class must implement all the methods specified by the <code v-pre>SalariedStaff</code> interface i.e., <code v-pre>setSalary(int)</code> and <code v-pre>getSalary()</code>.</p></box>
<p><strong>A class implementing an interface results in an <em>is-a</em> relationship</strong>, just like in class inheritance.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> In the example above, <code v-pre>AcademicStaff</code> <em>is a</em> <code v-pre>SalariedStaff</code>.  An <code v-pre>AcademicStaff</code> object can be used anywhere a <code v-pre>SalariedStaff</code> object is expected e.g. <code v-pre>SalariedStaff ss = new AcademicStaff()</code>.</p></box>
<p></p></div>
  <div></div></div></panel></div>
<div>
<panel type="seamless" expanded id="abstract-classes-and-methods">
  <span slot="header" class="card-title"><div><h4 id="abstract-classes-and-methods"><span>Abstract classes and methods</span><a class="fa fa-anchor" href="#abstract-classes-and-methods" onclick="event.stopPropagation()"></a></h4></div></span>
  <div class="indented">
<p><span class="badge badge-light"><span><span class="dimmed"><span><span><span aria-hidden="true" class="fas fa-trophy"></span></span> Can implement abstract classes</span></span></span></span></p><p></p><p></p>
<p></p>
  <div>
<box type="definition" seamless>
<div>
<p><strong>Abstract class</strong>: A class declared as an <em>abstract class</em> cannot be instantiated, but it can be subclassed.</p></div></box>
<p><strong>You can declare a class as <em>abstract</em> when a class is merely a representation of commonalities among its subclasses</strong> in which case it does not make sense to instantiate objects of that class.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The <code v-pre>Animal</code> class that exists as a generalization of its subclasses <code v-pre>Cat</code>, <code v-pre>Dog</code>, <code v-pre>Horse</code>, <code v-pre>Tiger</code> etc. can be declared as abstract because it does not make sense to instantiate an <code v-pre>Animal</code> object.</p></box>
<box type="definition" seamless>
<div>
<p><strong>Abstract method</strong>: An <em>abstract method</em> is a method signature without a method implementation.</p></div></box>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The <code v-pre>move</code> method of the <code v-pre>Animal</code> class is likely to be an abstract method as it is not possible to implement a <code v-pre>move</code> method at the <code v-pre>Animal</code> class level to fit all subclasses <span class="dimmed">because each animal type can move in a different way</span>.</p></box>
<p><strong>A class that has an abstract method becomes an abstract class</strong> because the class definition is incomplete (due to the missing method body) and it is not possible to create objects using an incomplete class definition.</p></div>
  <div></div></div></panel></div>
<div>
<panel type="seamless" expanded id="substitutability">
  <span slot="header" class="card-title"><div><h4 id="substitutability"><span>Substitutability</span><a class="fa fa-anchor" href="#substitutability" onclick="event.stopPropagation()"></a></h4></div></span>
  <div class="indented">
<p><span class="badge badge-light"><span><span class="dimmed"><span><span><span aria-hidden="true" class="fas fa-trophy"></span></span> Can explain substitutability</span></span></span></span></p><p></p><p></p>
<p></p>
  <div>
<p><strong>Every instance of a subclass is an instance of the superclass, but not vice-versa.</strong> As a result, inheritance allows <em>substitutability</em>: the ability to substitute a child class object where a parent class object is expected.</p>
<box>
<p><pic src="/website/book/oop/inheritance/substitutability/67968c10181cfb0e3ad27fd3dc6425ae.png"></pic></p>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> An <code v-pre>AcademicStaff</code> is an instance of a <code v-pre>Staff</code>, but a <code v-pre>Staff</code> is not necessarily an instance of an <code v-pre>AcademicStaff</code>. i.e. wherever an object of the superclass is expected, it can be substituted by an object of any of its subclasses.</p>
<p>The following code is valid because an <code v-pre>AcademicStaff</code> object is substitutable as a <code v-pre>Staff</code> object.</p>
<pre><code class="hljs java" v-pre><span>Staff staff = <span class="hljs-keyword">new</span> AcademicStaff(); <span class="hljs-comment">// OK</span><br></span></code></pre><p>But the following code is not valid <span class="dimmed">because <code v-pre>staff</code> is declared as a <code v-pre>Staff</code> type and therefore its value may or may not be of  type <code v-pre>AcademicStaff</code>, which is the type expected by variable <code v-pre>academicStaff</code>.</span></p>
<pre><code class="hljs java" v-pre><span>Staff staff;<br></span><span>...<br></span><span>AcademicStaff academicStaff = staff; <span class="hljs-comment">// Not OK</span><br></span></code></pre></box></div>
  <div></div></div></panel></div>
<div>
<panel type="seamless" expanded id="dynamic-and-static-binding">
  <span slot="header" class="card-title"><div><h4 id="dynamic-and-static-binding"><span>Dynamic and static binding</span><a class="fa fa-anchor" href="#dynamic-and-static-binding" onclick="event.stopPropagation()"></a></h4></div></span>
  <div class="indented">
<p><span class="badge badge-light"><span><span class="dimmed"><span><span><span aria-hidden="true" class="fas fa-trophy"></span></span> Can explain dynamic and static binding</span></span></span></span></p><p></p><p></p>
<p></p>
  <div>
<box type="definition" seamless>
  <div>
<p><strong>Dynamic binding</strong> (<span data-mb-component-type="tooltip" v-b-tooltip.hover.top.html="tooltipInnerContentGetter" class="trigger"><span data-mb-html-for="_content">There are subtle differences between late binding and dynamic binding, but they are beyond the scope of this document</span>aka late binding</span>): a mechanism where method calls in code are <span data-mb-component-type="tooltip" v-b-tooltip.hover.top.html="tooltipInnerContentGetter" class="trigger"><span data-mb-html-for="_content">deciding which method implementation to execute</span>resolved</span> at <span data-mb-component-type="tooltip" v-b-tooltip.hover.top.html="tooltipInnerContentGetter" class="trigger"><span data-mb-html-for="_content">at the moment the method call is executed</span>runtime</span>, rather than at compile time.</p></div></box>
<p><strong><span trigger="click" for="modal:dynamicAndStatic-overriding" v-b-popover.click.top.html="popoverGenerator" v-b-tooltip.click.top.html="tooltipContentGetter" v-on:click="$refs['modal:dynamicAndStatic-overriding'].show()" class="trigger-click">Overridden methods</span> are resolved using dynamic binding, and therefore resolves to the implementation in the actual type of the object.</strong></p>
<b-modal id="modal:dynamicAndStatic-overriding" hide-footer size="lg" modal-class="mb-zoom" ref="modal:dynamicAndStatic-overriding" class="algolia-no-index"><template slot="modal-title">Textbook <span><span aria-hidden="true" class="glyphicon glyphicon-log-in"></span></span></template>
  <div>
<div>
<p><panel src="/website/book/oop/inheritance/what/unit-inElsewhere-asFlat._include_.html" popup-url="/website/book/oop/inheritance/what" class="algolia-no-index"><template slot="_header"><p><span class="dimmed"><span><span aria-hidden="true" class="glyphicon glyphicon-education"></span></span> OOP → Inheritance → What</span></p></template></panel></p></div><p></p>
<p><span class="dimmed"><strong><span>Paradigms → OOP → Inheritance →
</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="overriding-2"><span>Overriding</span><a class="fa fa-anchor" href="#overriding-2" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<p><strong>Method <em>overriding</em> is when a sub-class changes the behavior inherited from the parent class</strong> by re-implementing the method. Overridden methods have the same name, same type signature, and same return type.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Consider the following case of <code v-pre>EvaluationReport</code> class inheriting the <code v-pre>Report</code> class:</p>
<div class="table-responsive"><table class="markbind-table table table-bordered table-striped"><thead>
<tr>
<th><code v-pre>Report</code> methods</th>
<th><code v-pre>EvaluationReport</code> methods</th>
<th>Overrides?</th></tr></thead>
<tbody>
<tr>
<td><code v-pre>print()</code></td>
<td><code v-pre>print()</code></td>
<td>Yes</td></tr>
<tr>
<td><code v-pre>write(String)</code></td>
<td><code v-pre>write(String)</code></td>
<td>Yes</td></tr>
<tr>
<td><code v-pre>read():String</code></td>
<td><code v-pre>read(int):String</code></td>
<td>No. <span class="dimmed">Reason: the two methods have different signatures; This is a case of <span trigger="click" for="modal:overriding-overloading" v-b-popover.click.top.html="popoverGenerator" v-b-tooltip.click.top.html="tooltipContentGetter" v-on:click="$refs['modal:overriding-overloading'].show()" class="trigger-click"> <em>overloading</em></span> (rather than overriding).</span></td></tr></tbody></table></div><b-modal id="modal:overriding-overloading" hide-footer size="lg" modal-class="mb-zoom" ref="modal:overriding-overloading" class="algolia-no-index"><template slot="modal-title"><strong>Overloading</strong></template>
  <div>
<div></div><p></p>
<p><span class="dimmed"><strong><span>Paradigms → OOP → Inheritance →
</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="overloading-3"><span>Overloading</span><a class="fa fa-anchor" href="#overloading-3" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<p><strong>Method overloading is when there are multiple methods with the same name but different type signatures.</strong> Overloading is used to indicate that multiple operations do similar things but take different parameters.</p>
<box type="definition" seamless>
<div>
<p><strong>Type signature</strong>: The <em>type signature</em> of an operation is the type sequence of the parameters. The return type and parameter names are not part of the type signature. However, the parameter order is significant.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Example:</p>
<div class="table-responsive"><table class="markbind-table table table-bordered table-striped"><thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Type Signature</th></tr></thead>
<tbody>
<tr>
<td style="text-align:center"><code v-pre>int add(int X, int Y)</code></td>
<td style="text-align:center"><code v-pre>(int, int)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void add(int A, int B)</code></td>
<td style="text-align:center"><code v-pre>(int, int)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void m(int X, double Y)</code></td>
<td style="text-align:center"><code v-pre>(int, double)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void m(double X, int Y)</code></td>
<td style="text-align:center"><code v-pre>(double, int)</code></td></tr></tbody></table></div></box></div></box>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> In the case below, the <code v-pre>calculate</code> method is overloaded because the two methods have the same name but different type signatures <code v-pre>(String)</code> and <code v-pre>(int)</code>.</p>
<ul>
<li><code v-pre>calculate(String): void</code></li>
<li><code v-pre>calculate(int): void</code></li></ul></box></div>
<div></div></div></div></div></b-modal></box></div>
<div>
  <div>
<panel expandable class="algolia-no-index"><template slot="_header"><p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p></template>
  <div>
<panel class="algolia-no-index"><template slot="_header"><p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span> Which methods override?</p></template>
<question>
<p>Which of these methods override another method? <span class="dimmed"><code v-pre>A</code> is the parent class. <code v-pre>B</code> inherits <code v-pre>A</code>.</span></p>
<img src="/website/book/oop/inheritance/overriding/images/overriding.png" height="220">
<p></p>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> a</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> b</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> c</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> d</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> e</li></ul>
<div slot="answer" class="algolia-no-index">
<p>d</p>
<p>Explanation: Method overriding requires a method in a <em>child class</em> to use the same method name and same parameter sequence used by one of its ancestors.</p></div></question></panel></div></panel></div></div></div></div></div></b-modal>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Consider the code below. The declared type of <code v-pre>s</code> is <code v-pre>Staff</code> and it appears as if the <code v-pre>adjustSalary(int)</code> operation of the <code v-pre>Staff</code> class is invoked.</p>
<pre><code class="hljs java" v-pre><span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustSalary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> byPercent)</span> </span>{<br></span><span>    <span class="hljs-keyword">for</span> (Staff s: staff) {<br></span><span>        s.adjustSalary(byPercent);<br></span><span>    }<br></span><span>}<br></span></code></pre><p>However, at runtime <code v-pre>s</code> can receive an object of any subclass of <code v-pre>Staff</code>. That means the <code v-pre>adjustSalary(int)</code> operation of the actual subclass object will be called. If the subclass does not override that operation, the operation defined in the superclass (in this case, <code v-pre>Staff</code> class) will be called.</p></box>
<box type="definition" seamless>
  <div>
<p><strong>Static binding</strong> (aka early binding): When a method call is resolved at compile time.</p></div></box>
<p><strong>In contrast, <span trigger="click" for="modal:dynamicAndStatic-overloading" v-b-popover.click.top.html="popoverGenerator" v-b-tooltip.click.top.html="tooltipContentGetter" v-on:click="$refs['modal:dynamicAndStatic-overloading'].show()" class="trigger-click">overloaded</span> methods are resolved using static binding.</strong></p>
<b-modal id="modal:dynamicAndStatic-overloading" hide-footer size="lg" modal-class="mb-zoom" ref="modal:dynamicAndStatic-overloading" class="algolia-no-index"><template slot="modal-title">Textbook <span><span aria-hidden="true" class="glyphicon glyphicon-log-in"></span></span></template>
  <div>
<div></div><p></p>
<p><span class="dimmed"><strong><span>Paradigms → OOP → Inheritance →
</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="overloading-4"><span>Overloading</span><a class="fa fa-anchor" href="#overloading-4" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<p><strong>Method overloading is when there are multiple methods with the same name but different type signatures.</strong> Overloading is used to indicate that multiple operations do similar things but take different parameters.</p>
<box type="definition" seamless>
<div>
<p><strong>Type signature</strong>: The <em>type signature</em> of an operation is the type sequence of the parameters. The return type and parameter names are not part of the type signature. However, the parameter order is significant.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Example:</p>
<div class="table-responsive"><table class="markbind-table table table-bordered table-striped"><thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Type Signature</th></tr></thead>
<tbody>
<tr>
<td style="text-align:center"><code v-pre>int add(int X, int Y)</code></td>
<td style="text-align:center"><code v-pre>(int, int)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void add(int A, int B)</code></td>
<td style="text-align:center"><code v-pre>(int, int)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void m(int X, double Y)</code></td>
<td style="text-align:center"><code v-pre>(int, double)</code></td></tr>
<tr>
<td style="text-align:center"><code v-pre>void m(double X, int Y)</code></td>
<td style="text-align:center"><code v-pre>(double, int)</code></td></tr></tbody></table></div></box></div></box>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> In the case below, the <code v-pre>calculate</code> method is overloaded because the two methods have the same name but different type signatures <code v-pre>(String)</code> and <code v-pre>(int)</code>.</p>
<ul>
<li><code v-pre>calculate(String): void</code></li>
<li><code v-pre>calculate(int): void</code></li></ul></box></div>
<div></div></div></div></div></b-modal>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Note how the constructor is overloaded in the class below. The method call <code v-pre>new Account()</code> is bound to the first constructor at compile time.</p>
<pre><code class="hljs java" v-pre><span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>{<br></span><span><br></span><span>    Account() {<br></span><span>        <span class="hljs-comment">// Signature: ()</span><br></span><span>        ...<br></span><span>    }<br></span><span><br></span><span>    Account(String name, String number, <span class="hljs-keyword">double</span> balance) {<br></span><span>        <span class="hljs-comment">// Signature: (String, String, double)</span><br></span><span>        ...<br></span><span>    }<br></span><span>}<br></span></code></pre><p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Similarly, the <code v-pre>calculateGrade</code> method is overloaded in the code below and a method call <code v-pre>calculateGrade(&quot;A1213232&quot;)</code> is bound to the second implementation, at compile time.</p>
<pre><code class="hljs java" v-pre><span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculateGrade</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] averages)</span> </span>{ ... }<br></span><span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculateGrade</span><span class="hljs-params">(String matric)</span> </span>{ ... }<br></span></code></pre></box></div>
  <div></div></div></panel></div></div></div></div></div></div>
        </div>
    </div>
</body>
<script src="../../../markbind/js/vue.min.js"></script>
<script src="../../../markbind/js/components.min.js"></script>
<script src="../../../markbind/js/bootstrap-utility.min.js"></script>
<script src="../../../markbind/js/polyfill.min.js"></script>
<script src="../../../markbind/js/bootstrap-vue.min.js"></script>
<script>
  const baseUrl = '/website'
  const enableSearch = true
</script>
<script src="../../../markbind/js/setup.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
    <script>
    function initAlgolia() {
      docsearch({
        apiKey: "0b1e4ae12d54a6114a4c5d131a850c2b",
        indexName: "nus-cs2103-ay1920s1",
        inputSelector: "#algolia-search-input",
        algoliaOptions: {"hitsPerPage":10},
        debug: false,
      });
    }
    MarkBind.afterSetup(initAlgolia);
  </script>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-122519234-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'UA-122519234-1');
    </script>
<script src="../../../markbind/layouts/default/scripts.js"></script>
</html>
